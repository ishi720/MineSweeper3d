<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        #info p {
            margin: 5px 0;
            font-size: 14px;
        }
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            text-align: right;
        }
        #status .emoji {
            font-size: 32px;
            margin-bottom: 10px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            margin-right: 5px;
        }
        button:hover {
            background: #45a049;
        }
        #gridToggle {
            background: #2196F3;
        }
        #gridToggle:hover {
            background: #0b7dda;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: default;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>3D ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</h2>
        <p>å·¦ã‚¯ãƒªãƒƒã‚¯: ãƒã‚¹ã‚’é–‹ã</p>
        <p>å³ã‚¯ãƒªãƒƒã‚¯: æ——ã‚’ç«‹ã¦ã‚‹</p>
        <p>ãƒ‰ãƒ©ãƒƒã‚°: å›è»¢</p>
        <p>ãƒ›ã‚¤ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ </p>
        <button onclick="resetGame()">æ–°ã—ã„ã‚²ãƒ¼ãƒ </button>
        <button id="gridToggle" onclick="toggleGrid()">ã‚°ãƒªãƒƒãƒ‰: OFF</button>
    </div>
    <div id="status">
        <div class="emoji" id="face">ğŸ™‚</div>
        <div>ğŸ’£ åœ°é›·: <span id="mines">30</span></div>
        <div>ğŸš© æ——: <span id="flags">0</span></div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, raycaster, mouse;
        let grid = [];
        let gridSize = 10;
        let mineCount = 30;
        let flagCount = 0;
        let revealedCount = 0;
        let gameOver = false;
        let cubes = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let hoveredCube = null;
        let gridLines = [];
        let gridVisible = false;

        // è‰²ã®å®šç¾©
        const colors = {
            unrevealed: 0x3498db,
            revealed: 0xecf0f1,
            mine: 0xe74c3c,
            flag: 0xf39c12,
            numbers: [
                0xecf0f1, // 0
                0x3498db, // 1
                0x2ecc71, // 2
                0xf39c12, // 3
                0xe74c3c, // 4
                0x9b59b6, // 5
                0x1abc9c, // 6
                0x34495e, // 7
                0xe67e22  // 8
            ]
        };

        function init() {
            // ã‚·ãƒ¼ãƒ³ã®è¨­å®š
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 30, 100);

            // ã‚«ãƒ¡ãƒ©ã®è¨­å®š
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(gridSize * 1.2, gridSize * 1.2, gridSize * 1.2);
            camera.lookAt(0, 0, 0);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®è¨­å®š
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ãƒ©ã‚¤ãƒˆã®è¨­å®š
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // ã‚°ãƒªãƒƒãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã®è¿½åŠ 
            createGridLines();

            // Raycasterã®è¨­å®š
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
            initGame();

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('contextmenu', onRightClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('wheel', onWheel);
            window.addEventListener('resize', onWindowResize);

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            animate();
        }

        function createGridLines() {
            const offset = gridSize / 2 - 0.5;

            // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç«‹æ–¹ä½“ã‚’å„ãƒã‚¹ã«é…ç½®
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const edges = new THREE.EdgesGeometry(geometry);
                        const material = new THREE.LineBasicMaterial({
                            color: 0x444444,
                            opacity: 0.1,
                            transparent: true
                        });
                        const wireframe = new THREE.LineSegments(edges, material);
                        wireframe.position.set(x - offset, y - offset, z - offset);
                        wireframe.visible = gridVisible;
                        scene.add(wireframe);
                        gridLines.push(wireframe);
                    }
                }
            }
        }

        function toggleGrid() {
            gridVisible = !gridVisible;
            gridLines.forEach(line => {
                line.visible = gridVisible;
            });
            document.getElementById('gridToggle').textContent = gridVisible ? 'ã‚°ãƒªãƒƒãƒ‰: ON' : 'ã‚°ãƒªãƒƒãƒ‰: OFF';
        }

        function initGame() {
            // ã‚°ãƒªãƒƒãƒ‰ã¨ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ã‚¯ãƒªã‚¢
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        if (grid[x] && grid[x][y] && grid[x][y][z]) {
                            if (grid[x][y][z].textMesh) {
                                scene.remove(grid[x][y][z].textMesh);
                            }
                        }
                    }
                }
            }
            grid = [];
            cubes.forEach(cube => scene.remove(cube));
            cubes = [];
            gridLines.forEach(line => scene.remove(line));
            gridLines = [];
            hoveredCube = null;
            gameOver = false;
            flagCount = 0;
            revealedCount = 0;
            updateStatus();

            // 3Dã‚°ãƒªãƒƒãƒ‰ã®åˆæœŸåŒ–
            for (let x = 0; x < gridSize; x++) {
                grid[x] = [];
                for (let y = 0; y < gridSize; y++) {
                    grid[x][y] = [];
                    for (let z = 0; z < gridSize; z++) {
                        grid[x][y][z] = {
                            isMine: false,
                            isRevealed: false,
                            isFlagged: false,
                            neighborMines: 0,
                            cube: null,
                            textMesh: null
                        };
                    }
                }
            }

            // åœ°é›·ã‚’é…ç½®
            let minesPlaced = 0;
            while (minesPlaced < mineCount) {
                const x = Math.floor(Math.random() * gridSize);
                const y = Math.floor(Math.random() * gridSize);
                const z = Math.floor(Math.random() * gridSize);
                if (!grid[x][y][z].isMine) {
                    grid[x][y][z].isMine = true;
                    minesPlaced++;
                }
            }

            // å‘¨å›²ã®åœ°é›·æ•°ã‚’è¨ˆç®—
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        if (!grid[x][y][z].isMine) {
                            grid[x][y][z].neighborMines = countNeighborMines(x, y, z);
                        }
                    }
                }
            }

            // ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ä½œæˆ
            createCubes();

            // ã‚°ãƒªãƒƒãƒ‰ã‚’å†ä½œæˆ
            createGridLines();
        }

        function createCubes() {
            const offset = gridSize / 2 - 0.5;

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                        const material = new THREE.MeshPhongMaterial({
                            color: colors.unrevealed,
                            shininess: 100,
                            transparent: true,
                            opacity: 0.8
                        });
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(x - offset, y - offset, z - offset);
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        cube.userData = { x, y, z };
                        scene.add(cube);
                        cubes.push(cube);
                        grid[x][y][z].cube = cube;
                    }
                }
            }
        }

        function countNeighborMines(x, y, z) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (dx === 0 && dy === 0 && dz === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        const nz = z + dz;
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && nz >= 0 && nz < gridSize) {
                            if (grid[nx][ny][nz].isMine) count++;
                        }
                    }
                }
            }
            return count;
        }

        function onMouseClick(event) {
            if (gameOver || isDragging) return;

            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);

            // æœ€åˆã®è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è¦‹ã¤ã‘ã‚‹
            for (let i = 0; i < intersects.length; i++) {
                const cube = intersects[i].object;
                if (cube.visible) {
                    const { x, y, z } = cube.userData;
                    revealCell(x, y, z);
                    break;
                }
            }
        }

        function onRightClick(event) {
            event.preventDefault();
            if (gameOver || isDragging) return;

            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);

            // æœ€åˆã®è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è¦‹ã¤ã‘ã‚‹
            for (let i = 0; i < intersects.length; i++) {
                const cube = intersects[i].object;
                if (cube.visible) {
                    const { x, y, z } = cube.userData;
                    toggleFlag(x, y, z);
                    break;
                }
            }
        }

        function toggleFlag(x, y, z) {
            const cell = grid[x][y][z];
            if (cell.isRevealed) return;

            cell.isFlagged = !cell.isFlagged;
            flagCount += cell.isFlagged ? 1 : -1;

            cell.cube.material.color.setHex(cell.isFlagged ? colors.flag : colors.unrevealed);
            updateStatus();
        }

        function revealCell(x, y, z) {
            const cell = grid[x][y][z];
            if (cell.isRevealed || cell.isFlagged) return;

            cell.isRevealed = true;
            revealedCount++;

            if (cell.isMine) {
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                gameOver = true;
                cell.cube.material.color.setHex(colors.mine);
                cell.cube.material.opacity = 1;
                revealAllMines();
                document.getElementById('face').textContent = 'ğŸ˜µ';
                setTimeout(() => alert('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼!'), 100);
            } else {
                // ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’éè¡¨ç¤ºã«
                cell.cube.visible = false;

                if (cell.neighborMines > 0) {
                    // æ•°å­—ã‚’3Dãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤º
                    addNumberText(x, y, z, cell.neighborMines);
                } else {
                    // å‘¨å›²ã®ã‚»ãƒ«ã‚’è‡ªå‹•çš„ã«é–‹ã
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                const nz = z + dz;
                                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && nz >= 0 && nz < gridSize) {
                                    revealCell(nx, ny, nz);
                                }
                            }
                        }
                    }
                }

                // å‹åˆ©åˆ¤å®š
                if (revealedCount === gridSize * gridSize * gridSize - mineCount) {
                    gameOver = true;
                    document.getElementById('face').textContent = 'ğŸ˜';
                    setTimeout(() => alert('ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢!'), 100);
                }
            }
        }

        function addNumberText(x, y, z, number) {
            const offset = gridSize / 2 - 0.5;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã§æ•°å­—ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆ
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // èƒŒæ™¯ã‚’é€æ˜ã«
            ctx.clearRect(0, 0, 256, 256);

            // æ•°å­—ã®è‰²ã‚’è¨­å®š
            const numberColors = ['#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
            ctx.fillStyle = numberColors[Math.min(number - 1, 7)];
            ctx.font = 'bold 180px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, 128, 128);

            // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆ
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x - offset, y - offset, z - offset);
            sprite.scale.set(0.7, 0.7, 0.7);
            scene.add(sprite);

            grid[x][y][z].textMesh = sprite;
        }

        function revealAllMines() {
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        if (grid[x][y][z].isMine) {
                            grid[x][y][z].cube.material.color.setHex(colors.mine);
                            grid[x][y][z].cube.material.opacity = 1;
                        }
                    }
                }
            }
        }

        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseMove(event) {
            // ãƒ‰ãƒ©ãƒƒã‚°ã«ã‚ˆã‚‹å›è»¢
            if (event.buttons === 1) {
                isDragging = true;
                const deltaX = event.movementX;
                const deltaY = event.movementY;

                // ã‚«ãƒ¡ãƒ©ã‚’çƒé¢åº§æ¨™ã§å›è»¢
                const radius = Math.sqrt(
                    camera.position.x ** 2 +
                    camera.position.y ** 2 +
                    camera.position.z ** 2
                );

                const theta = Math.atan2(camera.position.x, camera.position.z);
                const phi = Math.acos(camera.position.y / radius);

                const newTheta = theta - deltaX * 0.01;
                const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + deltaY * 0.01));

                camera.position.x = radius * Math.sin(newPhi) * Math.sin(newTheta);
                camera.position.y = radius * Math.cos(newPhi);
                camera.position.z = radius * Math.sin(newPhi) * Math.cos(newTheta);

                camera.lookAt(0, 0, 0);
            } else {
                setTimeout(() => { isDragging = false; }, 100);
            }

            // ãƒ›ãƒãƒ¼æ¤œå‡º
            if (!isDragging && !gameOver) {
                updateMousePosition(event);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubes);

                // å‰å›ãƒ›ãƒãƒ¼ã—ã¦ã„ãŸã‚­ãƒ¥ãƒ¼ãƒ–ã®è‰²ã‚’å…ƒã«æˆ»ã™
                if (hoveredCube && hoveredCube.visible) {
                    const { x, y, z } = hoveredCube.userData;
                    const cell = grid[x][y][z];
                    if (!cell.isRevealed) {
                        hoveredCube.material.color.setHex(cell.isFlagged ? colors.flag : colors.unrevealed);
                    }
                }

                hoveredCube = null;

                // æœ€åˆã®è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è¦‹ã¤ã‘ã¦ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                for (let i = 0; i < intersects.length; i++) {
                    const cube = intersects[i].object;
                    if (cube.visible) {
                        const { x, y, z } = cube.userData;
                        const cell = grid[x][y][z];
                        if (!cell.isRevealed) {
                            hoveredCube = cube;
                            // ãƒ›ãƒãƒ¼æ™‚ã¯å°‘ã—æ˜ã‚‹ãã™ã‚‹
                            const hoverColor = cell.isFlagged ? 0xffd700 : 0x5dade2;
                            cube.material.color.setHex(hoverColor);
                        }
                        break;
                    }
                }
            }
        }

        function onWheel(event) {
            event.preventDefault();

            // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‹ã‚‰åŸç‚¹ã¾ã§ã®è·é›¢ã‚’è¨ˆç®—
            const radius = Math.sqrt(
                camera.position.x ** 2 +
                camera.position.y ** 2 +
                camera.position.z ** 2
            );

            // ãƒ›ã‚¤ãƒ¼ãƒ«ã®å‹•ãã«å¿œã˜ã¦ã‚ºãƒ¼ãƒ ï¼ˆè·é›¢ã‚’å¤‰æ›´ï¼‰
            const zoomSpeed = 0.1;
            const delta = event.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            const newRadius = Math.max(5, Math.min(50, radius * delta)); // æœ€å°5ã€æœ€å¤§50ã«åˆ¶é™

            // ç¾åœ¨ã®æ–¹å‘ã‚’ç¶­æŒã—ãŸã¾ã¾è·é›¢ã ã‘å¤‰æ›´
            const scale = newRadius / radius;
            camera.position.x *= scale;
            camera.position.y *= scale;
            camera.position.z *= scale;

            camera.lookAt(0, 0, 0);
        }

        function updateStatus() {
            document.getElementById('mines').textContent = mineCount;
            document.getElementById('flags').textContent = flagCount;
        }

        function resetGame() {
            document.getElementById('face').textContent = 'ğŸ™‚';
            initGame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // åˆæœŸåŒ–
        init();
    </script>
</body>
</html>